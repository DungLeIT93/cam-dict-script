/* global api */
class envi_Cambridge {
    constructor(options) {
        // Giữ lại constructor để nhận options
        this.options = options;
        this.maxexample = 2;
        this.word = '';
    }

    // Các hàm này có thể là một phần của API, cứ giữ lại
    async displayName() {
        return 'Cambridge EN->VI Dictionary';
    }

    setOptions(options) {
        this.options = options;
        this.maxexample = options.maxexample;
    }

    // Hàm renderCSS (chuyển thành một hàm của class)
    renderCSS() {
        return `
            <style>
                span.ipa { color: #888; }
                span.pos { text-transform: lowercase; font-size: 0.9em; margin-right: 5px; padding: 2px 4px; color: white; background-color: #0d47a1; border-radius: 3px; }
                span.eng_tran { margin: 0; padding: 0; display: block; }
                span.vi_tran { color: #0d47a1; display: block; }
                ul.sents { font-size: 0.9em; list-style: square inside; margin: 5px 0; padding: 5px; background: rgba(13, 71, 161, 0.1); border-radius: 5px; }
                li.sent { margin: 0; padding: 2px 0; }
                span.eng_sent { margin-right: 5px; display: block;}
                span.vi_sent { color: #0d47a1; display: block; }
            </style>`;
    }

    // Hàm T (Helper)
    T(node) {
        return node ? node.innerText.trim() : '';
    }

    // *** Hàm findTerm được sửa lại theo template ***
    findTerm(word) {
        this.word = word;
        let self = this; // Lưu lại 'this' để dùng trong .then()
        let notes = [];

        // Trả về một Promise đúng như template yêu cầu
        return new Promise((resolve, reject) => {
            if (!word) {
                resolve([]);
                return;
            }

            let base = 'https://dictionary.cambridge.org/dictionary/english-vietnamese/';
            let url = base + encodeURIComponent(word);

            // Dùng api.fetch với .then() và .catch() thay vì async/await
            api.fetch(url)
                .then(data => {
                    // Toàn bộ logic xử lý HTML (parsing) nằm ở đây
                    let parser = new DOMParser();
                    let doc = parser.parseFromString(data, 'text/html');

                    let entries = doc.querySelectorAll('.pr.entry-body__el') || [];
                    for (const entry of entries) {
                        let definitions = [];
                        let audios = [];

                        let expression = self.T(entry.querySelector('.di-title .hw'));
                        if (!expression) continue;

                        let reading = '';
                        let reading_uk_el = entry.querySelector('.uk .ipa');
                        let reading_us_el = entry.querySelector('.us .ipa');
                        if (reading_uk_el) reading += `UK <span class="ipa">/${self.T(reading_uk_el)}/</span> `;
                        if (reading_us_el) reading += `US <span class="ipa">/${self.T(reading_us_el)}/</span>`;
                        
                        let pos = self.T(entry.querySelector('.posgram.dpos-g .pos'));
                        pos = pos ? `<span class='pos'>${pos}</span>` : '';

                        let audio_uk_el = entry.querySelector('.uk source[type="audio/mpeg"]');
                        if (audio_uk_el) audios.push('https://dictionary.cambridge.org' + audio_uk_el.getAttribute('src'));
                        
                        let audio_us_el = entry.querySelector('.us source[type="audio/mpeg"]');
                        if (audio_us_el) audios.push('https://dictionary.cambridge.org' + audio_us_el.getAttribute('src'));

                        let sense_blocks = entry.querySelectorAll('.pr.dsense') || [];
                        for (const block of sense_blocks) {
                            let def_blocks = block.querySelectorAll('.def-block.ddef_block') || [];
                            for (const def_block of def_blocks) {
                                let eng_tran = self.T(def_block.querySelector('.def.ddef_d'));
                                if (!eng_tran) continue;
                                let vi_tran = self.T(def_block.querySelector('.def-body .trans.dtrans'));
                                let definition = '';
                                if (!block.closest('.phrase-block')) {
                                    definition += pos;
                                }
                                definition += `<span class='eng_tran'>${eng_tran}</span>`;
                                if (vi_tran) {
                                    definition += `<span class='vi_tran'>${vi_tran}</span>`;
                                }
                                let examples = def_block.querySelectorAll('.examp.dexamp') || [];
                                if (examples.length > 0 && self.maxexample > 0) {
                                    definition += '<ul class="sents">';
                                    for (const [index, examp] of examples.entries()) {
                                        if (index >= self.maxexample) break;
                                        let eng_examp = self.T(examp.querySelector('.eg'));
                                        let vi_examp = self.T(examp.querySelector('.trans.dtrans'));
                                        if (eng_examp) {
                                            const regex = new RegExp(`\\b(${self.word})\\b`, 'gi');
                                            eng_examp = eng_examp.replace(regex, `<b>$1</b>`);
                                            definition += `<li class='sent'>
                                                             <span class='eng_sent'>${eng_examp}</span>
                                                             ${vi_examp ? `<span class='vi_sent'>${vi_examp}</span>` : ''}
                                                           </li>`;
                                        }
                                    }
                                    definition += '</ul>';
                                }
                                definitions.push(definition);
                            }
                        }
                        
                        if (definitions.length > 0) {
                            let css = self.renderCSS(); // Gọi hàm renderCSS
                            notes.push({
                                css,
                                expression,
                                reading,
                                definitions,
                                audios
                            });
                        }
                    }
                    
                    // Khi xử lý xong, gọi resolve() để trả kết quả
                    resolve(notes);

                })
                .catch(err => {
                    // Nếu có lỗi, gọi reject()
                    console.error("Lỗi khi tải từ điển Cambridge EN-VI:", err);
                    reject(err);
                });
        });
    }
}
